#!/usr/bin/python

import types
import os
import hmac
import struct
import cStringIO
from hashlib import sha256

from M2Crypto import EVP

from common.utils.Basic import log_msg, log_ex, _ # pylint: disable-msg=W0611
from common import Globals
from common.utils import Basic

IV_LENGTH = 16
MESSAGE_FORMAT = "!%ss"%(Globals.SYMMETRIC_KEY_BYTES) 
BANK_KEY_LENGTH = 48
  
class SymmetricKey():
  """A wrapper around M2 that makes access to that class more
  Pythonic and incorporates an hmac; SymmetricKey will create a new key unless
  it is given an authBlob; an authBlob can be generated by the pack method on an 
  existing key."""
  
  def __init__(self, key):
    """Initializes itself with the string of random data passed in, or generates
    its own random data if none is passed.
    @param key: bank's public key
    @param authBlob: contains data to initialize a key
    @type authBlob: binary packed by self.pack()"""
    self.alg = 'aes_256_cfb'
    self.key = key
  
  def make_sym_key(self, randomData=None):
    if not randomData:
      self.randomData = os.urandom(Globals.SYMMETRIC_KEY_BYTES)
    else:
      self.randomData = randomData
    self.hmacKey = self.randomData
    self.iv = self.randomData[:IV_LENGTH]
    self.decryptCipher = EVP.Cipher(self.alg, self.randomData, self.iv, 0)
    self.encryptCipher = EVP.Cipher(self.alg, self.randomData, self.iv, 1)
      
  def reset(self):
    #self.key.IV = self.iv
    self.decryptCipher = EVP.Cipher(self.alg, self.randomData, self.iv, 0)
    self.encryptCipher = EVP.Cipher(self.alg, self.randomData, self.iv, 1)
  
  def pack(self):
    return struct.pack(MESSAGE_FORMAT, self.randomData)
    
  def unpack(self, msg):
    return struct.unpack(MESSAGE_FORMAT, msg)
    
  def encrypt(self, msg):
    raise Exception('Not implemented')
  
  def decrypt(self, encryptedMsg):
    return msg

  def make_hmac(self, msg):
    """creates an hmac out of msg using key
    @msg: message to mac"""
    return hmac.new(self.hmacKey, msg, sha256).digest()

class ClientSymKey(SymmetricKey):
  def __init__(self, key):
    SymmetricKey.__init__(self, key)
    self.make_sym_key()
    
  def encrypt(self, msg):
    Basic.validate_type(msg, types.StringType)
    #make hmac
    mac = self.make_hmac(msg)
    inbuf = cStringIO.StringIO(mac + msg)
    outbuf = cStringIO.StringIO()
    outbuf.write(self.encryptCipher.update(inbuf.read()))
    outbuf.write(self.encryptCipher.final()) #no idea what this does because it is undocumented
    encryptedKeyConstructor = self.key.encrypt(self.randomData)
    encryptedKeyConstructor = struct.pack('!%ss'% BANK_KEY_LENGTH, encryptedKeyConstructor)
    msg = encryptedKeyConstructor+outbuf.getvalue()
    return msg
    
  def decrypt(self, msg):
    Basic.validate_type(msg, types.StringType)
    #decrypt the message
    inbuf = cStringIO.StringIO(msg)
    outbuf = cStringIO.StringIO()
    outbuf.write(self.decryptCipher.update(inbuf.read()))
    outbuf.write(self.decryptCipher.final())
    msg = outbuf.getvalue()
    mac = msg[:32]
    msg = msg[32:]
    #validate the HMAC
    if self.make_hmac(msg) != mac:
      raise Exception('HMAC does not authenticate, is something bad going on?')
    return msg
    
class ServerSymKey(SymmetricKey):
  def __init__(self, key):
    SymmetricKey.__init__(self, key)
    
  def encrypt(self, msg):
    """expects decrypt to be called first to initialize the keys"""
    Basic.validate_type(msg, types.StringType)
    #make hmac
    mac = self.make_hmac(msg)
    inbuf = cStringIO.StringIO(mac + msg)
    outbuf = cStringIO.StringIO()
    outbuf.write(self.encryptCipher.update(inbuf.read()))
    outbuf.write(self.encryptCipher.final()) #no idea what this does because it is undocumented
    return outbuf.getvalue()
    
  def decrypt(self, msg):
    Basic.validate_type(msg, types.StringType)
    #decrypt the message
    encRandomData, msg = Basic.read_message('!%ss'%( BANK_KEY_LENGTH), msg)
    randomData = self.key.decrypt(encRandomData[0])
    self.make_sym_key(randomData)
    inbuf = cStringIO.StringIO(msg)
    outbuf = cStringIO.StringIO()
    outbuf.write(self.decryptCipher.update(inbuf.read()))
    outbuf.write(self.decryptCipher.final())
    msg = outbuf.getvalue()
    mac = msg[:32]
    msg = msg[32:]
    #validate the HMAC
    if self.make_hmac(msg) != mac:
      raise Exception('HMAC does not authenticate, is something bad going on?')
    return msg

if __name__=="__main__":
  from common.classes import PrivateKey
  key = PrivateKey.PrivateKey(BANK_KEY_LENGTH*8)
  ckey = ClientSymKey(key)
  bkey = ServerSymKey(key)
  msg = 'hello world'
  msg = ckey.encrypt(msg)
  msg = bkey.decrypt(msg)
  print msg
  msg +='!'
  msg = bkey.encrypt(msg)
  msg = ckey.decrypt(msg)
  print msg
